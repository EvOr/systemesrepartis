\section{Mode d'emploi}

Pour lancer le serveur et les clients, nous avons réalisé deux scripts shell. Le fichier \verb|server.sh| ressemble à un démon qui empêche le lancement en double du server et permet de le controler en utilisant les commandes start, stop et restart... De son côté, le fichier client.sh permet de lancer un xterm par client afin d'agir sur ceux-ci.

Evidemment, il est possible de lancer le tout à la main. Auquel cas la syntaxe de lancement du client est la suivante : \verb|client/client <Nom du client> <port>|. Le serveur quand à lui n'attend pas de paramètres sur la ligne de commande et se lance par : \verb|server/server|.

\section{Problèmes rencontrés et solutions}
\subsection{Terminaison du serveur}

La gestion simplifié des RPC que nous avons utilisée (usage des fonctions registerrpc et callrpc) empêchent la terminaison du serveur une fois les trois clients connectés. Il serait évidemment possible pour ceux-ci de signaler qu'ils exécutent l'algorithme de Ricart et Agrawala au serveur pour que celui-ci se termine (à l'aide d'une nouvelle fonction RPC \verb|we_are_all_set| par exemple). Mais une telle méthodologie ne nous plaisait pas.

c'est pour cette raison que nous avons choisi de gérer proprement la terminaison du programme sur un \verb|Ctrl+C|, correspondant au signal 2 (\verb|SIG_INT|) et écrit un démon permettant de quitter et de relancer le serveur à volonté. La vraie solution, selon nous, serait d'utiliser les méthodes avancées de programmation des RPC (via les fonctions \verb|svc_*|) beaucoup plus polyvalentes.

Lorsque l'on exécute un \verb|Ctrl+C| pour fermer le serveur, celui-ci se détache du portmaper. Il a suffit d'armer le signal 2 au lancement de l'application, pour pouvoir le catcher au moment opportun, libérer les ressources utilisées, et fermer le serveur.

\subsection{Le multiplexage des I/O grace à ``select''}

L'écriture de ce programme a été l'occasion de découvrir la fonction \verb|select| définie dans le fichier \verb|unistd.h|. Celle-ci permet de mettre le programme en attente sur deux descripteurs de fichiers (à la fois l'entrée standard et la socket). Sans cette fonction \verb|select|, nous aurions été réduits à gérer deux threads avec tous les problèmes de partage de ressources que cela implique.

\subsection{Ce n'est pas de l'objet}

De manière un peu moins technique (et un peu plus philosophique...), nous avons éprouvé quelques difficultés à revenir au C après avoir fait du Java ou du C++ voir du Python durant nos stages et projets à l'ISIMA. Néanmoins, ce retour aux sources nous a permis d'apprécier une nouvelle fois la toute puissance de Vim (complétion du code, syntaxe, gestion des fenêtres, des onglets, auto-indentation) et d'exploiter pleinement le potentiel de git (système de gestion de version distribué).

\section{Un Cas d'utilisation}

